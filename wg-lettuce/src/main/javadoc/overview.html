<body>
  <a href="http://github.com/wg/lettuce">lettuce</a> is a scalable thread-safe Java
  {@link com.lambdaworks.redis.RedisClient RedisClient} providing both
  {@link com.lambdaworks.redis.RedisConnection synchronous} and
  {@link com.lambdaworks.redis.RedisAsyncConnection asynchronous} connections.

  Multiple threads may share one connection provided they avoid blocking and transactional
  operations such as <a href="http://redis.io/commands/blpop">BLPOP</a> and
  <a href="http://redis.io/commands/multi">MULTI</a>/<a href="http://redis.io/commands/exec">EXEC</a>.
  Multiple open connections are efficiently managed by the excellent
  <a href="http://www.jboss.org/netty">netty</a> NIO framework.

  <p>
    Each redis command is implemented by one or more methods with names identical to the lowercase
    redis command name. Complex commands with multiple modifiers that change the result type include
    the CamelCased modifier as part of the command name, e.g.
    {@link com.lambdaworks.redis.RedisConnection#zrangebyscore zrangebyscore} and
    {@link com.lambdaworks.redis.RedisConnection#zrangebyscoreWithScores zrangebyscoreWithScores}.
  </p>

  <p>
    Redis connections are designed to be long-lived, and if the connection is lost will reconnect
    until {@code close()} is called. Pending commands that have not timed out will be (re)sent after
    successful reconnection.
  </p>

  <p>
    All connections inherit a default timeout from their {@link com.lambdaworks.redis.RedisClient}
    and will throw a {@link com.lambdaworks.redis.RedisException} when non-blocking commands fail
    to return a result before the timeout expires. The timeout defaults to 60 seconds and
    may be changed via {@link com.lambdaworks.redis.RedisClient#setDefaultTimeout} or for
    each individual connection.
  </p>
</body>
